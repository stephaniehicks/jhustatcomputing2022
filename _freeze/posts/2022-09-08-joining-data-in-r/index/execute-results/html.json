{
  "hash": "30ba434620fb38efd1f1dff198f1ffda",
  "result": {
    "markdown": "---\ntitle: \"Joining data in R\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to relational data and join functions in the dplyr R package\"\ndate: 2022-09-08\ncategories: [module 1, week 2, R, programming, dplyr, here, tidyverse]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://r4ds.had.co.nz/relational-data>\n2.  <https://rafalab.github.io/dsbook/joining-tables>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://rdpeng.github.io/Biostat776/lecture-joining-data-in-r-basics>\n-   <https://r4ds.had.co.nz/relational-data>\n-   <https://rafalab.github.io/dsbook/joining-tables>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to define relational data and keys\n-   Be able to define the three types of join functions for relational data\n-   Be able to implement mutational join functions\n:::\n\n# Relational data\n\nData analyses rarely involve only a single table of data. \n\nTypically you have many tables of data, and you **must combine the datasets** to answer the questions that you are interested in. \n\nCollectively, **multiple tables of data are called relational data** because it is the *relations*, not just the individual datasets, that are important.\n\nRelations are **always defined between a pair of tables**. All other relations are built up from this simple idea: the relations of three or more tables are always a property of the relations between each pair. \n\nSometimes both elements of a pair can be the same table! This is needed if, for example, you have a table of people, and each person has a reference to their parents.\n\nTo work with relational data you **need verbs that work with pairs of tables**.\n\n:::{.callout-tip}\n\n### Three important families of verbs\n\nThere are three families of verbs designed to work with relational data:\n\n-   [**Mutating joins**](https://r4ds.had.co.nz/relational-data.html#mutating-joins): A mutating join allows you to **combine variables from two tables**. It first matches observations by their keys, then copies across variables from one table to the other on the right side of the table (similar to `mutate()`). We will discuss a few of these below.\n    - See @sec-mutjoins for Table of mutating joins.\n-   [**Filtering joins**](https://r4ds.had.co.nz/relational-data.html#filtering-joins): Filtering joins **match observations** in the same way as mutating joins, **but affect the observations, not the variables** (i.e. filter observations from one data frame based on whether or not they match an observation in the other). \n    - Two types: `semi_join(x, y)` and `anti_join(x, y)`.\n-   [**Set operations**](https://r4ds.had.co.nz/relational-data.html#set-operations): Treat **observations as if they were set elements**. Typically used less frequently, but occasionally useful when you want to break a single complex filter into simpler pieces. All these operations work with a complete row, comparing the values of every variable. These expect the x and y inputs to have the same variables, and treat the observations like sets: \n    - Examples of set operations: `intersect(x, y)`, `union(x, y)`, and `setdiff(x, y)`.\n\n:::\n\n## Keys\n\nThe **variables used to connect each pair of tables** are called **keys**. A key is a variable (or set of variables) that uniquely identifies an observation. In simple cases, a single variable is sufficient to identify an observation.\n\n\n:::{.callout-tip}\n\n### Note\n\nThere are two types of keys:\n\n-   A **primary key** uniquely identifies an observation in its own table.\n-   A **foreign key** uniquely identifies an observation in another table.\n\n:::\n\nLet's consider an example to help us understand the difference between a **primary key** and **foreign key**. \n\n## Example of keys \n\nImagine you are conduct a study and **collecting data on subjects and a health outcome**. \n\nOften, subjects will **make multiple visits** (a so-called longitudinal study) and so we will record the outcome for each visit. Similarly, we may record other information about them, such as the kind of housing they live in.\n\n### The first table\n\nThis code creates a simple table with some made up data about some hypothetical subjects' outcomes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\noutcomes <- tibble(\n        id = rep(c(\"a\", \"b\", \"c\"), each = 3),\n        visit = rep(0:2, 3),\n        outcome = rnorm(3 * 3, 3)\n)\n\nprint(outcomes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  id    visit outcome\n  <chr> <int>   <dbl>\n1 a         0   3.74 \n2 a         1   4.36 \n3 a         2   3.23 \n4 b         0   3.22 \n5 b         1   0.290\n6 b         2   1.33 \n7 c         0   3.14 \n8 c         1   3.29 \n9 c         2   3.39 \n```\n:::\n:::\n\n\nNote that subjects are labeled by a unique identifer in the `id` column.\n\n### A second table\n\nHere is some code to create a second table (we will be joining the first and second tables shortly). This table contains some data about the hypothetical subjects' housing situation by recording the type of house they live in.\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"a\", \"b\", \"c\"),\n        house = c(\"detached\", \"rowhouse\", \"rowhouse\")\n)\n\nprint(subjects)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  id    house   \n  <chr> <chr>   \n1 a     detached\n2 b     rowhouse\n3 c     rowhouse\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Question\n\nWhat is the **primary key** and **foreign key**? \n\n- The `outcomes$id` is a **primary key** because it uniquely identifies each subject in the `outcomes` table.\n- The `subjects$id` is a **foreign key** because it appears in the `subjects` table where it matches each subject to a unique `id`. \n\n:::\n\n\n# Mutating joins {#sec-mutjoins}\n\nThe `dplyr` package provides a set of **functions for joining two data frames** into a single data frame based on a set of key columns. \n\nThere are several functions in the `*_join()` family. \n\n- These functions all merge together two data frames\n- They differ in how they handle observations that exist in one but not both data frames. \n\nHere, are the **four functions from this family** that you will likely use the most often:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n|Function       |What it includes in merged data frame                                                                     |\n|:--------------|:---------------------------------------------------------------------------------------------------------|\n|`left_join()`  |Includes all observations in the left data frame, whether or not there is a match in the right data frame |\n|`right_join()` |Includes all observations in the right data frame, whether or not there is a match in the left data frame |\n|`inner_join()` |Includes only observations that are in both data frames                                                   |\n|`full_join()`  |Includes all observations from both data frames                                                           |\n:::\n:::\n\n\n![](https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png)\n\n[[Source from R for Data Science](https://r4ds.had.co.nz/relational-data#relational-data)]\n\n## Left Join\n\nRecall the `outcomes` and `subjects` datasets above. \n\n\n::: {.cell}\n\n```{.r .cell-code}\noutcomes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  id    visit outcome\n  <chr> <int>   <dbl>\n1 a         0   3.74 \n2 a         1   4.36 \n3 a         2   3.23 \n4 b         0   3.22 \n5 b         1   0.290\n6 b         2   1.33 \n7 c         0   3.14 \n8 c         1   3.29 \n9 c         2   3.39 \n```\n:::\n\n```{.r .cell-code}\nsubjects\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  id    house   \n  <chr> <chr>   \n1 a     detached\n2 b     rowhouse\n3 c     rowhouse\n```\n:::\n:::\n\n\nSuppose we want to create a table that combines the information about houses (`subjects`) with the information about the outcomes (`outcomes`).\n\nWe can use the `left_join()` function to merge the `outcomes` and `subjects` tables and produce the output above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x = outcomes, y = subjects, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 4\n  id    visit outcome house   \n  <chr> <int>   <dbl> <chr>   \n1 a         0   3.74  detached\n2 a         1   4.36  detached\n3 a         2   3.23  detached\n4 b         0   3.22  rowhouse\n5 b         1   0.290 rowhouse\n6 b         2   1.33  rowhouse\n7 c         0   3.14  rowhouse\n8 c         1   3.29  rowhouse\n9 c         2   3.39  rowhouse\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Note\n\nThe `by` argument indicates the column (or columns) that the two tables have in common.\n\n:::\n\n### Left Join with Incomplete Data\n\nIn the previous examples, the `subjects` table didn't have a `visit` column. But suppose it did? Maybe people move around during the study. We could image a table like this one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"a\", \"b\", \"c\"),\n        visit = c(0, 1, 0),\n        house = c(\"detached\", \"rowhouse\", \"rowhouse\"),\n)\n\nprint(subjects)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  id    visit house   \n  <chr> <dbl> <chr>   \n1 a         0 detached\n2 b         1 rowhouse\n3 c         0 rowhouse\n```\n:::\n:::\n\n\nWhen we left joint the tables now we get:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(outcomes, subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 a         0   3.74  detached\n2 a         1   4.36  <NA>    \n3 a         2   3.23  <NA>    \n4 b         0   3.22  <NA>    \n5 b         1   0.290 rowhouse\n6 b         2   1.33  <NA>    \n7 c         0   3.14  rowhouse\n8 c         1   3.29  <NA>    \n9 c         2   3.39  <NA>    \n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Note\n\nTwo things to point out here: \n\n1. If we do not have information about a subject's housing in a given visit, the `left_join()` function automatically inserts an `NA` value to indicate that it is missing.\n\n2. We can \"join\" on multiple variable (e.g. here we joined on the `id` and the `visit` columns).\n\n:::\n\n\nWe may even have a situation where we are missing housing data for a subject completely. The following table has no information about subject `a`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubjects <- tibble(\n        id = c(\"b\", \"c\"),\n        visit = c(1, 0),\n        house = c(\"rowhouse\", \"rowhouse\"),\n)\n\nsubjects\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  id    visit house   \n  <chr> <dbl> <chr>   \n1 b         1 rowhouse\n2 c         0 rowhouse\n```\n:::\n:::\n\n\nBut we can still join the tables together and the `house` values for subject `a` will all be `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(x = outcomes, y = subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 a         0   3.74  <NA>    \n2 a         1   4.36  <NA>    \n3 a         2   3.23  <NA>    \n4 b         0   3.22  <NA>    \n5 b         1   0.290 rowhouse\n6 b         2   1.33  <NA>    \n7 c         0   3.14  rowhouse\n8 c         1   3.29  <NA>    \n9 c         2   3.39  <NA>    \n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Important\n\nThe bottom line for `left_join()` is that it **always retains the values in the \"left\" argument** (in this case the `outcomes` table). \n\n- If there are no corresponding values in the \"right\" argument, `NA` values will be filled in.\n\n:::\n\n## Inner Join\n\nThe `inner_join()` function only **retains the rows of both tables** that have corresponding values. Here we can see the difference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(x = outcomes, y = subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 b         1   0.290 rowhouse\n2 c         0   3.14  rowhouse\n```\n:::\n:::\n\n\n## Right Join\n\nThe `right_join()` function is like the `left_join()` function except that it **gives priority to the \"right\" hand argument**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join(x = outcomes, y = subjects, by = c(\"id\", \"visit\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  id    visit outcome house   \n  <chr> <dbl>   <dbl> <chr>   \n1 b         1   0.290 rowhouse\n2 c         0   3.14  rowhouse\n```\n:::\n:::\n\n\n# Summary\n\n-   `left_join()` is useful for merging a \"large\" data frame with a \"smaller\" one while retaining all the rows of the \"large\" data frame\n\n-   `inner_join()` gives you the intersection of the rows between two data frames\n\n-   `right_join()` is like `left_join()` with the arguments reversed (likely only useful at the end of a pipeline)\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  If you had three data frames to combine with a shared key, how would you join them using the verbs you now know?\n\n2.  Using `df1` and `df2` below, what is the difference between `inner_join(df1, df2)`, `semi_join(df1, df2)` and `anti_join(df1, df2)`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create first example data frame\ndf1 <- data.frame(ID = 1:3,\n                  X1 = c(\"a1\", \"a2\", \"a3\"))\n# Create second example data frame\ndf2 <- data.frame(ID = 2:4, \n                  X2 = c(\"b1\", \"b2\", \"b3\"))\n```\n:::\n\n\n3.  Try changing the order from the above e.g. `inner_join(df2, df1)`, `semi_join(df2, df1)` and `anti_join(df2, df1)`. What changed? What did not change?\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   <https://rdpeng.github.io/Biostat776/lecture-joining-data-in-r-basics>\n-   <https://r4ds.had.co.nz/relational-data>\n-   <https://rafalab.github.io/dsbook/joining-tables>\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}