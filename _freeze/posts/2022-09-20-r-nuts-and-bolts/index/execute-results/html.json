{
  "hash": "1168d51ab64e4c02576914d44424589e",
  "result": {
    "markdown": "---\ntitle: \"R Nuts and Bolts\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to data types and objects in R\"\ndate: 2022-09-20\ncategories: [module 4, week 4, R, programming]\n---\n\n\n<!-- Add interesting quote -->\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://rafalab.github.io/dsbook/r-basics>\n2.  <https://r4ds.had.co.nz/vectors.html?q=typeof#vectors>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://rdpeng.github.io/Biostat776/lecture-r-nuts-and-bolts>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Know the 5 basic built-in data types (or classes) of objects in R\n-   Know the types of attributes (or metadata) R objects can have\n-   Be able to create a vector, matrix, data frame, factor, and list in R\n-   Recognize missing values in R\n:::\n\n# R Nuts and Bolts\n\n## Entering Input\n\nAt the R prompt we type expressions. The `<-` symbol is the assignment operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmsg <- \"hello\"\n```\n:::\n\n\nThe grammar of the language determines **whether an expression is complete or not**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <-  ## Incomplete expression\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:2:0: unexpected end of input\n1: x <-  ## Incomplete expression\n   ^\n```\n:::\n:::\n\n\nThe `#` character indicates a **comment**. \n\nAnything to the right of the `#` (including the `#` itself) is ignored. **This is the only comment character in R**. \n\nUnlike some other languages, R does not support multi-line comments or comment blocks.\n\n## Evaluation\n\nWhen a complete expression is entered at the prompt, **it is evaluated and the result of the evaluated expression is returned**. \n\nThe result may be **auto-printed**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5  ## nothing printed\nx       ## auto-printing occurs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nprint(x)  ## explicit printing\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nThe `[1]` shown in the output indicates that `x` is a vector and `5` is its first element.\n\nTypically with **interactive work**, we **do not explicitly print objects** with the `print()` function; it is much easier to just auto-print them by typing the name of the object and hitting return/enter. \n\nHowever, when **writing scripts, functions, or longer programs**, there is sometimes a **need to explicitly print objects** because auto-printing does not work in those settings.\n\nWhen an R vector is printed you will notice that an index for the vector is printed in square brackets `[]` on the side. For example, see this integer sequence of length 20.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 11:30\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11 12 13 14 15 16 17 18 19 20 21 22\n[13] 23 24 25 26 27 28 29 30\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\nThe numbers in the square brackets are not part of the vector itself, they are merely part of the **printed output**.\n\n:::{.callout-tip}\n\n### Note\n\nWith R, it's important that one understand that **there is a difference between the actual R object and the manner in which that R object is printed to the console**.\n\nOften, the printed output may have additional bells and whistles to make the output more friendly to the users. However, these bells and whistles are not inherently part of the object.\n\n:::\n\n\n:::{.callout-tip}\n\n### Pro-tip\n\nThe `:` operator is used to create integer sequences.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5:0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 4 3 2 1 0\n```\n:::\n\n```{.r .cell-code}\n-15:15\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -15 -14 -13 -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3\n[20]   4   5   6   7   8   9  10  11  12  13  14  15\n```\n:::\n:::\n\n\n\n:::\n\n## R Objects\n\nThe most basic type of R object is a **vector**. \n\n### Vectors \n\nThere is really only one rule about vectors in R, which is that \n\n> **A vector can only contain objects of the same class**\n\nTo understand what we mean here, we need to dig a little deeper. We will come back this in just a minute. \n\n#### Types of vectors\n\nThere are [two types of **vectors**](https://r4ds.had.co.nz/vectors.html?q=typeof#vector-basics) in R:\n\n1. **Atomic vectors**:\n\n    -   **logical**: `FALSE`, `TRUE`, and `NA`\n    -   **integer** (and **doubles**): these are known collectively as **numeric** vectors (or real numbers)\n    -   **complex**: complex numbers\n    -   **character**: the most complex type of atomic vector, because each element of a character vector is a string, and a string can contain an arbitrary amount of data\n    -   **raw**: used to store fixed-length sequences of bytes. These are not commonly used directly in data analysis and I won't cover them here.\n\n2. **Lists**, which are sometimes called **recursive vectors** because lists can contain other lists.\n\n![](https://d33wubrfki0l68.cloudfront.net/1d1b4e1cf0dc5f6e80f621b0225354b0addb9578/6ee1c/diagrams/data-structures-overview.png){.preview-image}\n\n\\[**Source**: [R 4 Data Science](https://r4ds.had.co.nz/vectors.html?q=typeof#vector-basics)\\]\n\n\n:::{.callout-tip}\n\n### Note\n\nThere's one other related object: NULL. \n\n- NULL is often used to represent the absence of a vector (as opposed to `NA` which is used to represent the absence of a value in a vector).\n- NULL typically behaves like a vector of length 0.\n\n:::\n\n\n#### Create an empty vector \n\nEmpty vectors can be created with the `vector()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector(mode = \"numeric\", length = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0\n```\n:::\n\n```{.r .cell-code}\nvector(mode = \"logical\", length = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nvector(mode = \"character\", length = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\" \"\" \"\" \"\"\n```\n:::\n:::\n\n\n#### Creating a non-empty vector\n\nThe `c()` function can be used to **create vectors of objects** by **concatenating** things together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(0.5, 0.6)       ## numeric\nx <- c(TRUE, FALSE)    ## logical\nx <- c(T, F)           ## logical\nx <- c(\"a\", \"b\", \"c\")  ## character\nx <- 9:29              ## integer\nx <- c(1+0i, 2+4i)     ## complex\n```\n:::\n\n\n:::{.callout-tip}\n\n### Note\n\nIn the above example, `T` and `F` are short-hand ways to specify `TRUE` and `FALSE`.\n\nHowever, in general, one should try to use the explicit `TRUE` and `FALSE` values when indicating logical values. \n\nThe `T` and `F` values are primarily there for when you're feeling lazy.\n\n:::\n\n\n\n#### Lists\n\nSo, I know I said there is one rule about vectors: \n\n> **A vector can only contain objects of the same class**\n\nBut of course, like any good rule, there is an exception, which is a **list** (which we will get to in greater details a bit later).\n\nFor now, just know a **list** is **represented as a vector** but can **contain objects of different classes**. Indeed, that's usually why we use them.\n\n\n:::{.callout-tip}\n\n### Note\n\nThe main difference between **atomic vectors** and **lists** is that atomic vectors are **homogeneous**, while lists can be **heterogeneous**. \n\n:::\n\n\n### Numerics\n\n**Integer** and **double** vectors are known collectively as **numeric vectors**. \n\nIn R, numbers are doubles by default.\n\nTo make an integer, place an `L` after the number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(4L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n::: callout-tip\n\n### Note\n\nThe distinction between integers and doubles is not usually important, but there are two important differences that you should be aware of:\n\n-   **Doubles** are approximations!\n-   **Doubles** represent floating point numbers that can not always be precisely represented with a fixed amount of memory. This means that you should consider all doubles to be approximations.\n\n:::\n\n\n::: callout-note\n\n### Question\n\nLet's explore this. What is square of the square root of two? i.e. $(\\sqrt{2})^2$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- sqrt(2) ^ 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nTry subtracting 2 from `x`? What happened? \n\n::: {.cell}\n\n```{.r .cell-code}\n## try it here\n```\n:::\n\n\n:::\n\n\n\n### Numbers\n\nNumbers in R are generally treated as **numeric objects** (i.e. double precision real numbers). \n\nThis means that even if you see a number like \"1\" or \"2\" in R, which you might think of as integers, they are likely represented behind the scenes as numeric objects (so something like \"1.00\" or \"2.00\"). \n\nThis isn't important most of the time...except when it is! \n\nIf you **explicitly want an integer**, you need to specify the `L` suffix. So entering `1` in R gives you a numeric object; entering `1L` explicitly gives you an integer object.\n\n:::{.callout-tip}\n\n### Note\n\nThere is also a **special number `Inf` which represents infinity**. This allows us to represent entities like `1 / 0`. This way, `Inf` can be used in ordinary calculations; e.g. `1 / Inf` is 0.\n\nThe value **`NaN` represents an undefined value** (\"not a number\"); e.g. 0 / 0; `NaN` can also be thought of as a missing value (more on that later)\n\n:::\n\n### Attributes\n\nR objects can have **attributes**, which are like **metadata for the object**. \n\nThese metadata can be very useful in that they **help to describe the object**. \n\nFor example, **column names** on a data frame help to tell us what data are contained in each of the columns. Some examples of R object attributes are\n\n-   names, dimnames\n-   dimensions (e.g. matrices, arrays)\n-   class (e.g. integer, numeric)\n-   length\n-   other user-defined attributes/metadata\n\nAttributes of an object (if any) can be accessed using the `attributes()` function. Not all R objects contain attributes, in which case the `attributes()` function returns `NULL`.\n\nHowever, every **vector** has two key properties:\n\n1.  Its **type**, which you can determine with `typeof()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\ntypeof(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n2.  Its **length**, which you can determine with `length()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\"a\", \"b\", 1:10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] \"b\"\n\n[[3]]\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n\n## Mixing Objects\n\nThere are occasions when **different classes of R objects get mixed together**.\n\nSometimes this happens by accident but it can also happen on purpose. \n\n:::{.callout-note}\n\n### Question\n\nLet's use `typeof()` to ask what happens when we mix different classes of R objects together. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(1.7, \"a\")\ny <- c(TRUE, 2)\ny <- c(\"a\", TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it here\n```\n:::\n\n\n:::\n\nWhy is this happening? \n\nIn each case above, we are **mixing objects of two different classes** in a vector. \n\nBut remember that the only rule about vectors says this is not allowed?\n\nWhen different objects are mixed in a vector, **coercion** occurs so that **every element in the vector is of the same class**.\n\nIn the example above, we see the effect of **implicit coercion**. \n\nWhat R tries to do is find a way to represent all of the objects in the vector in a reasonable fashion. Sometimes this does exactly what you want and...sometimes not. \n\nFor example, combining a numeric object with a character object will create a character vector, because numbers can usually be easily represented as strings.\n\n## Explicit Coercion\n\nObjects can be explicitly coerced from one class to another using the `as.*()` functions, if available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0:6\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 2 3 4 5 6\n```\n:::\n\n```{.r .cell-code}\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nas.character(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\"\n```\n:::\n:::\n\n\nSometimes, **R can't figure out how to coerce an object** and this can result in `NA`s being produced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"b\", \"c\")\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n\n```{.r .cell-code}\nas.logical(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA NA\n```\n:::\n:::\n\n\n:::{.callout-note}\n\n### Question \n\nLet's try to convert the `x` vector above to integers. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it here \n```\n:::\n\n\n:::\n\n\nWhen nonsensical coercion takes place, you will usually get a warning from R.\n\n\n## Matrices\n\n**Matrices** are **vectors with a dimension attribute**. \n\n- The **dimension attribute** is **itself an integer vector** of length 2 (number of rows, number of columns)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(nrow = 2, ncol = 3) \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n```\n:::\n\n```{.r .cell-code}\ndim(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\nattributes(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$dim\n[1] 2 3\n```\n:::\n:::\n\n\nMatrices are **constructed column-wise**, so entries can be thought of starting in the \"upper left\" corner and running down the columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:6, nrow = 2, ncol = 3) \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n:::\n\n\n:::{.callout-note}\n\n### Question \n\nLet's try to use `attributes()` function to look at the attributes of the `m` object\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it here \n```\n:::\n\n\n:::\n\n\nMatrices can also be created directly from vectors by adding a dimension attribute.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- 1:10 \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\ndim(m) <- c(2, 5)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n:::\n:::\n\n\nMatrices can be created by **column-binding** or **row-binding** with the `cbind()` and `rbind()` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\ny <- 10:12\ncbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     x  y\n[1,] 1 10\n[2,] 2 11\n[3,] 3 12\n```\n:::\n:::\n\n\n:::{.callout-note}\n\n### Question \n\nLet's try to use `rbind()` to row bind `x` and `y` above. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it here \n```\n:::\n\n\n:::\n\n## Lists\n\nLists are a special type of **vector** that **can contain elements of different classes**. Lists are a very important data type in R and you should get to know them well. \n\n:::{.callout-tip}\n\n### Pro-tip\n\nLists, in combination with the various \"apply\" functions discussed later, make for a powerful combination.\n\n:::\n\nLists can be explicitly created using the `list()` function, which takes an arbitrary number of arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(1, \"a\", TRUE, 1 + 4i) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[1] TRUE\n\n[[4]]\n[1] 1+4i\n```\n:::\n:::\n\n\nWe can also create an empty list of a prespecified length with the `vector()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- vector(\"list\", length = 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nNULL\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n\n[[5]]\nNULL\n```\n:::\n:::\n\n\n## Factors\n\n**Factors** are used to represent **categorical data** and can be unordered or ordered. One can think of a factor as an integer vector where each integer has a **label**.\n\n:::{.callout-tip}\n\n### Pro-tip\n\nFactors are important in statistical modeling and are treated specially by modelling functions like `lm()` and `glm()`.\n\n:::\n\nUsing factors with labels is **better** than using integers because factors are self-describing. \n\n:::{.callout-tip}\n\n### Pro-tip\n\nHaving a variable that has values \"Yes\" and \"No\" or \"Smoker\" and \"Non-Smoker\" is better than a variable that has values 1 and 2.\n\n:::\n\nFactor objects can be created with the `factor()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"no\")) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] yes yes no  yes no \nLevels: no yes\n```\n:::\n\n```{.r .cell-code}\ntable(x) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx\n no yes \n  2   3 \n```\n:::\n\n```{.r .cell-code}\n## See the underlying representation of factor\nunclass(x)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2 1 2 1\nattr(,\"levels\")\n[1] \"no\"  \"yes\"\n```\n:::\n:::\n\n\n\n:::{.callout-note}\n\n### Question \n\nLet's try to use `attributes()` function to look at the attributes of the `x` object\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## try it here \n```\n:::\n\n\n:::\n\n\nOften factors will be automatically created for you when you read in a dataset using a function like `read.table()`. \n\n- Those functions often **default to creating factors when they encounter data that look like characters or strings**.\n\nThe order of the levels of a factor can be set using the `levels` argument to `factor()`. This can be important in linear modeling because the first level is used as the baseline level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"no\"))\nx  ## Levels are put in alphabetical order\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] yes yes no  yes no \nLevels: no yes\n```\n:::\n\n```{.r .cell-code}\nx <- factor(c(\"yes\", \"yes\", \"no\", \"yes\", \"no\"),\n            levels = c(\"yes\", \"no\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] yes yes no  yes no \nLevels: yes no\n```\n:::\n:::\n\n\n## Missing Values\n\n**Missing values** are denoted by `NA` or `NaN` for undefined mathematical operations.\n\n-   `is.na()` is used to test objects if they are `NA`\n\n-   `is.nan()` is used to test for `NaN`\n\n-   `NA` values have a class also, so there are integer `NA`, character `NA`, etc.\n\n-   A `NaN` value is also `NA` but the converse is not true\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create a vector with NAs in it\nx <- c(1, 2, NA, 10, 3)  \n## Return a logical vector indicating which elements are NA\nis.na(x)    \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n## Return a logical vector indicating which elements are NaN\nis.nan(x)   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Now create a vector with both NA and NaN values\nx <- c(1, 2, NaN, NA, 4)\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nis.nan(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\n## Data Frames\n\n**Data frames** are used to store **tabular data** in R. They are an important type of object in R and are used in a variety of statistical modeling applications. Hadley Wickham's package [dplyr](https://github.com/hadley/dplyr) has an optimized set of functions designed to work efficiently with data frames.\n\nData frames are **represented as a special type of list** where **every element of the list has to have the same length**. \n\n- Each element of the list can be thought of as a column\n- The length of each element of the list is the number of rows\n\nUnlike matrices, **data frames can store different classes of objects in each column**. Matrices must have every element be the same class (e.g. all integers or all numeric).\n\nIn addition to column names, indicating the names of the variables or predictors, data frames have a special attribute called `row.names` which indicate information about each row of the data frame.\n\nData frames are usually created by reading in a dataset using the `read.table()` or `read.csv()`. However, data frames can also be created explicitly with the `data.frame()` function or they can be coerced from other types of objects like lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- data.frame(foo = 1:4, bar = c(T, T, F, F)) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  foo   bar\n1   1  TRUE\n2   2  TRUE\n3   3 FALSE\n4   4 FALSE\n```\n:::\n\n```{.r .cell-code}\nnrow(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nncol(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"foo\" \"bar\"\n\n$class\n[1] \"data.frame\"\n\n$row.names\n[1] 1 2 3 4\n```\n:::\n:::\n\n\n\nData frames can be converted to a matrix by calling `data.matrix()`. While it might seem that the `as.matrix()` function should be used to coerce a data frame to a matrix, almost always, what you want is the result of `data.matrix()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.matrix(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     foo bar\n[1,]   1   1\n[2,]   2   1\n[3,]   3   0\n[4,]   4   0\n```\n:::\n\n```{.r .cell-code}\nattributes(data.matrix(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$dim\n[1] 4 2\n\n$dimnames\n$dimnames[[1]]\nNULL\n\n$dimnames[[2]]\n[1] \"foo\" \"bar\"\n```\n:::\n:::\n\n\n\n:::{.callout-note}\n\n### Question\n\nLet's use the `palmerpenguins` dataset. \n\n1. What attributes does `penguins` have? \n2. Try using `typeof()` with `penguins`. \n3. What are the levels in the `species` column in the `penguins` dataset? \n4. Create a logical vector for all the penguins measured from 2008. \n5. Create a matrix with just the columns `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, and `body_mass_g` \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\npenguins \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n```\n:::\n:::\n\n\n:::\n\n\n## Names\n\nR objects can have **names**, which is very useful for writing readable code and self-describing objects. \n\nHere is an example of assigning names to an integer vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nnames(x) <- c(\"New York\", \"Seattle\", \"Los Angeles\") \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   New York     Seattle Los Angeles \n          1           2           3 \n```\n:::\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"New York\"    \"Seattle\"     \"Los Angeles\"\n```\n:::\n\n```{.r .cell-code}\nattributes(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"New York\"    \"Seattle\"     \"Los Angeles\"\n```\n:::\n:::\n\n\n**Lists can also have names**, which is often very useful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\"Los Angeles\" = 1, Boston = 2, London = 3) \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`Los Angeles`\n[1] 1\n\n$Boston\n[1] 2\n\n$London\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Los Angeles\" \"Boston\"      \"London\"     \n```\n:::\n:::\n\n\n**Matrices can have both column and row names**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:4, nrow = 2, ncol = 2)\ndimnames(m) <- list(c(\"a\", \"b\"), c(\"c\", \"d\")) \nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  c d\na 1 3\nb 2 4\n```\n:::\n:::\n\n\nColumn names and row names can be set separately using the `colnames()` and `rownames()` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(m) <- c(\"h\", \"f\")\nrownames(m) <- c(\"x\", \"z\")\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  h f\nx 1 3\nz 2 4\n```\n:::\n:::\n\n\n:::{.callout-tip}\n\n### Note\n\nFor data frames, there is a separate function for setting the row names, the `row.names()` function. \n\nAlso, data frames do not have column names, they just have names (like lists). \n\nSo to set the column names of a data frame just use the `names()` function. Yes, I know its confusing. \n\nHere's a quick summary:\n\n| Object     | Set column names | Set row names |\n|------------|------------------|---------------|\n| data frame | `names()`        | `row.names()` |\n| matrix     | `colnames()`     | `rownames()`  |\n\n:::\n\n# Summary\n\nThere are a variety of different builtin-data types in R. In this chapter we have reviewed the following\n\n-   atomic classes: numeric, logical, character, integer, complex\n-   vectors, lists\n-   factors\n-   missing values\n-   data frames and matrices\n\nAll R objects can have attributes that help to describe what is in the object. Perhaps the most useful attribute is names, such as column and row names in a data frame, or simply names in a vector or list. Attributes like dimensions are also important as they can modify the behavior of objects, like turning a vector into a matrix.\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Describe the difference between is.finite(x) and !is.infinite(x).\n\n2.  A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research.\n\n3.  What functions from the readr package allow you to turn a string into logical, integer, and double vector?\n\n4.  Try and make a tibble that has columns with different lengths. What happens?\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   <https://rdpeng.github.io/Biostat776/lecture-r-nuts-and-bolts>\n-   <https://rafalab.github.io/dsbook/r-basics>\n-   <https://r4ds.had.co.nz/vectors.html?q=typeof#vectors>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}