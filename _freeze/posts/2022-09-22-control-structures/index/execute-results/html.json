{
  "hash": "3b6b37730d110eb8138df82f55ad8dd8",
  "result": {
    "markdown": "---\ntitle: \"Control Structures\"\nauthor: \n  - name: Stephanie Hicks\n    url: https://stephaniehicks.com\n    affiliation: Department of Biostatistics, Johns Hopkins\n    affiliation_url: https://publichealth.jhu.edu\ndescription: \"Introduction to control the flow of execution of a series of R expressions\"\ndate: 2022-09-22\ncategories: [module 4, week 4, R, programming]\n---\n\n\n<!-- Add interesting quote -->\n\n\n# Pre-lecture materials\n\n### Read ahead\n\n::: callout-note\n## Read ahead\n\n**Before class, you can prepare by reading the following materials:**\n\n1.  <https://rafalab.github.io/dsbook/programming-basics>\n2.  <https://r4ds.had.co.nz/iteration>\n:::\n\n### Acknowledgements\n\nMaterial for this lecture was borrowed and adopted from\n\n-   <https://rdpeng.github.io/Biostat776/lecture-control-structures>\n-   <https://r4ds.had.co.nz/iteration>\n\n# Learning objectives\n\n::: callout-note\n# Learning objectives\n\n**At the end of this lesson you will:**\n\n-   Be able to use commonly used control structures including `if`, `while`, `repeat`, and `for`\n-   Be able to skip an iteration of a loop using `next`\n-   Be able to exit a loop immediately using `break`\n:::\n\n# Control Structures\n\n**Control structures** in R allow you to **control the flow of execution of a series of R expressions**.\n\nBasically, control structures allow you to put some \"logic\" into your R code, rather than just always executing the same R code every time.\n\nControl structures **allow you to respond to inputs or to features of the data** and execute different R expressions accordingly.\n\nCommonly used control structures are\n\n-   `if` and `else`: testing a condition and acting on it\n\n-   `for`: execute a loop a fixed number of times\n\n-   `while`: execute a loop *while* a condition is true\n\n-   `repeat`: execute an infinite loop (must `break` out of it to stop)\n\n-   `break`: break the execution of a loop\n\n-   `next`: skip an interation of a loop\n\n::: callout-tip\n### Pro-tip\n\nMost control structures are not used in interactive sessions, but rather when writing functions or longer expressions.\n\nHowever, these constructs do not have to be used in functions and it's a good idea to become familiar with them before we delve into functions.\n:::\n\n## `if`-`else`\n\nThe `if`-`else` combination is probably the most commonly used control structure in R (or perhaps any language). This structure allows you to test a condition and act on it depending on whether it's true or false.\n\nFor starters, you can just use the `if` statement.\n\n``` r\nif(<condition>) {\n        ## do something\n} \n## Continue with rest of code\n```\n\nThe above code does nothing if the condition is false. If you have an action you want to execute when the condition is false, then you need an `else` clause.\n\n``` r\nif(<condition>) {\n        ## do something\n} \nelse {\n        ## do something else\n}\n```\n\nYou can have a series of tests by following the initial `if` with any number of `else if`s.\n\n``` r\nif(<condition1>) {\n        ## do something\n} else if(<condition2>)  {\n        ## do something different\n} else {\n        ## do something different\n}\n```\n\nHere is an example of a valid if/else structure.\n\nLet's use the `runif(n, min=0, max=1)` function which draws a random value between a min and max value with the default being between 0 and 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- runif(n=1, min=0, max=10)  \nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1601887\n```\n:::\n:::\n\n\nThen, we can write and `if`-`else` statement that tests whethere `x` is greater than 3 or not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nIf `x` is greater than 3, then the first condition occurs. If `x` is not greater than 3, then the second condition occurs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(x > 3) {\n    y <- 10\n  } else {\n    y <- 0\n  }\n```\n:::\n\n\nFinally, we can auto print `y` to see what the value is.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nThis expression can also be written a different (but equivalent!) way in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- if(x > 3) {\n    10\n  } else { \n    0\n  }\n\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n::: callout-tip\n### Note\n\nNeither way of writing this expression is more correct than the other.\n\nWhich one you use will **depend on your preference** and perhaps those of the team you may be working with.\n:::\n\nOf course, the `else` clause is not necessary. You could have a series of if clauses that always get executed if their respective conditions are true.\n\n``` r\nif(<condition1>) {\n\n}\n\nif(<condition2>) {\n\n}\n```\n\n::: callout-note\n### Question\n\nLet's use the `palmerpenguins` dataset and write a if-else statement that\n\n1.  Randomly samples a value from a standard normal distribution (**Hint**: check out the `rnorm(n, mean = 0, sd = 1)` function in base R).\n2.  If the value is larger than 0, use `dplyr` functions to keep only the `Chinstrap` penguins.\n3.  Otherwise, keep only the `Gentoo` penguins.\n4.  Re-run the code 10 times and look at output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\npenguins \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_…¹ body_…² sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema…  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema…  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema…  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema…  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n```\n:::\n:::\n\n:::\n\n## `for` Loops\n\n**For loops** are pretty much the only looping construct that you will need in R. While you may occasionally find a need for other types of loops, in my experience doing data analysis, I've found very few situations where a for loop was not sufficient.\n\nIn R, for loops take an iterator variable and assign it successive values from a sequence or vector.\n\nFor loops are most commonly used for **iterating over the elements of an object** (list, vector, etc.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:10) {\n        print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n```\n:::\n:::\n\n\nThis **loop takes the `i` variable** and in **each iteration of the loop** gives it values 1, 2, 3, ..., 10, then **executes the code** within the curly braces, and then the loop exits.\n\nThe following three loops all have the same behavior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## define the loop to iterate over\nx <- c(\"a\", \"b\", \"c\", \"d\")\n\n## create for loop\nfor(i in 1:4) {\n        ## Print out each element of 'x'\n        print(x[i])  \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nWe can also print just the iteration value (`i`) itself\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## define the loop to iterate over\nx <- c(\"a\", \"b\", \"c\", \"d\")\n\n## create for loop\nfor(i in 1:4) {\n        ## Print out just 'i'\n        print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n```\n:::\n:::\n\n\n### `seq_along()`\n\nThe `seq_along()` function is **commonly used in conjunction with `for` loops** in order to generate an integer sequence based on the length of an object (or `ncol()` of an R object) (in this case, the object `x`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n:::\n\n```{.r .cell-code}\nseq_along(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n\nThe `seq_along()` function takes in a vector and then **returns a sequence of integers** that is the same length as the input vector. It doesn't matter what class the vector is.\n\nLet's put `seq_along()` and `for` loops together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Generate a sequence based on length of 'x'\nfor(i in seq_along(x)) {   \n        print(x[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nIt is not necessary to use an index-type variable (i.e. `i`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(babyshark in x) {\n        print(babyshark)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(candyisgreat in x) {\n        print(candyisgreat)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(RememberToVote in x) {\n        print(RememberToVote)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nYou can use any character index you want (but not with symbols or numbers).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(1999 in x) {\n        print(1999)\n}\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:1:5: unexpected numeric constant\n1: for(1999\n        ^\n```\n:::\n:::\n\n\nFor one line loops, the curly braces are not strictly necessary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:4) print(x[i])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nHowever, I like to use curly braces even for one-line loops, because that way if you decide to expand the loop to multiple lines, you won't be burned because you forgot to add curly braces (and you **will** be burned by this).\n\n::: callout-note\n### Question\n\nLet's use the `palmerpenguins` dataset. Here are the tasks:\n\n1.  Start a `for` loop\n2.  Iterate over the columns of `penguins`\n3.  For each column, extract the values of that column (**Hint**: check out the `pull()` function in `dplyr`).\n4.  Using a `if`-`else` statement, test whether or not the values in the column are numeric or not (**Hint**: remember the `is.numeric()` function to test if a value is numeric).\n5.  If they are numeric, compute the column mean. Otherwise, report a `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# try it yourself\n```\n:::\n\n:::\n\n### Nested `for` loops\n\n`for` loops can be **nested** inside of each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:6, nrow = 2, ncol = 3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in seq_len(nrow(x))) {\n        for(j in seq_len(ncol(x))) {\n                print(x[i, j])\n        }   \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 3\n[1] 5\n[1] 2\n[1] 4\n[1] 6\n```\n:::\n:::\n\n\n::: callout-tip\n### Note\n\nThe `j` index goes across the columns. That's why we values 1, 3, etc.\n:::\n\nNested loops are commonly needed for **multidimensional or hierarchical data structures** (e.g. matrices, lists). Be careful with nesting though.\n\nNesting beyond 2 to 3 levels often makes it **difficult to read/understand the code**.\n\nIf you find yourself in need of a large number of nested loops, you may want to **break up the loops by using functions** (discussed later).\n\n## `while` Loops\n\n**`while` loops** begin by **testing a condition**.\n\nIf it is true, then they execute the loop body.\n\nOnce the loop body is executed, the condition is tested again, and so forth, until the condition is false, after which the loop exits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount <- 0\nwhile(count < 10) {\n        print(count)\n        count <- count + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n```\n:::\n:::\n\n\n`while` loops can potentially result in infinite loops if not written properly. **Use with care!**\n\nSometimes there will be more than one condition in the test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 5\nset.seed(1)\n\nwhile(z >= 3 && z <= 10) {\n        coin <- rbinom(1, 1, 0.5)\n        \n        if(coin == 1) {  ## random walk\n                z <- z + 1\n        } else {\n                z <- z - 1\n        } \n}\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n::: callout-tip\n### Pro-tip\n\nWhat's the difference between using one `&` or two `&&` ?\n\nIf you use only one `&`, these are vectorized operations, meaning they can **return a vector**, like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n-2:2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2 -1  0  1  2\n```\n:::\n\n```{.r .cell-code}\n((-2:2) >= 0) & ((-2:2) <= 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\nIf you use two `&&` (as above), then these **conditions are evaluated left to right**. For example, in the above code, if `z` were less than 3, the second test would not have been evaluated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(2 >= 0) && (-2 <= 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n(-2 >= 0) && (-2 <= 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n:::\n\n## `repeat` Loops\n\n**`repeat` initiates an infinite loop** right from the start. These are **not commonly used** in statistical or data analysis applications, but they do have their uses.\n\n::: callout-tip\n### IMPORTANT (READ THIS AND DON'T FORGET... I'M SERIOUS... YOU WANT TO REMEMBER THIS.. FOR REALZ PLZ REMEMBER THIS)\n\nThe only way to exit a `repeat` loop is to call `break`.\n:::\n\nOne possible paradigm might be in an iterative algorithm where you may be searching for a solution and you do not want to stop until you are close enough to the solution.\n\nIn this kind of situation, you often don't know in advance how many iterations it's going to take to get \"close enough\" to the solution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx0 <- 1\ntol <- 1e-8\n\nrepeat {\n        x1 <- computeEstimate()\n        \n        if(abs(x1 - x0) < tol) {  ## Close enough?\n                break\n        } else {\n                x0 <- x1\n        } \n}\n```\n:::\n\n\n::: callout-tip\n### Note\n\nThe above code will not run if the `computeEstimate()` function is not defined (I just made it up for the purposes of this demonstration).\n:::\n\n::: callout-tip\n### Pro-tip\n\nThe loop above is a bit **dangerous** because there is no guarantee it will stop.\n\nYou could get in a situation where the values of `x0` and `x1` oscillate back and forth and never converge.\n\nBetter to set a hard limit on the number of iterations by using a `for` loop and then report whether convergence was achieved or not.\n:::\n\n## `next`, `break`\n\n`next` is used to skip an iteration of a loop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:100) {\n        if(i <= 20) {\n                ## Skip the first 20 iterations\n                next                 \n        }\n        ## Do something here\n}\n```\n:::\n\n\n`break` is used to exit a loop immediately, regardless of what iteration the loop may be on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:100) {\n      print(i)\n\n      if(i > 20) {\n              ## Stop loop after 20 iterations\n              break  \n      }\t\t\n}\n```\n:::\n\n\n# Summary\n\n-   Control structures like `if`, `while`, and `for` allow you to control the flow of an R program\n-   Infinite loops should generally be avoided, even if (you believe) they are theoretically correct.\n-   Control structures mentioned here are primarily useful for writing programs; for command-line interactive work, the \"apply\" functions are more useful.\n\n# Post-lecture materials\n\n### Final Questions\n\nHere are some post-lecture questions to help you think about the material discussed.\n\n::: callout-note\n### Questions\n\n1.  Write for loops to compute the mean of every column in `mtcars`.\n\n2.  Imagine you have a directory full of CSV files that you want to read in. You have their paths in a vector, `files <- dir(\"data/\", pattern = \"\\\\.csv$\", full.names = TRUE)`, and now want to read each one with `read_csv()`. Write the for loop that will load them into a single data frame.\n\n3.  What happens if you use `for (nm in names(x))` and `x` has no names? What if only some of the elements are named? What if the names are not unique?\n:::\n\n### Additional Resources\n\n::: callout-tip\n-   <https://rdpeng.github.io/Biostat776/lecture-control-structures>\n-   <https://rafalab.github.io/dsbook/programming-basics>\n-   <https://r4ds.had.co.nz/iteration>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}